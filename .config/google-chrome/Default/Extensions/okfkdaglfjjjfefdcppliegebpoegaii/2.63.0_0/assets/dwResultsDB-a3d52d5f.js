const j="DWHiddenDB",m="hidden",_=()=>new Promise((c,a)=>{const t=indexedDB.open(j,1);t.onupgradeneeded=s=>{const n=s.target.result;n.objectStoreNames.contains(m)||n.createObjectStore(m,{keyPath:"key"})},t.onsuccess=s=>c(s.target.result),t.onerror=()=>a(t.error)});function g(c,a,t=!0){return new Promise((s,n)=>{const e=o=>{try{a.close()}finally{o&&t?n(o):s()}};c.oncomplete=()=>e(),c.onabort=()=>e(c.error||new Error("Transaction aborted")),c.onerror=()=>e(c.error||new Error("Transaction error"))})}const b=(c,a)=>`${c}|${a}`;async function S(c,a){const t=await _(),s=t.transaction([m],"readwrite"),n=s.objectStore(m),e=g(s,t,!0);try{await new Promise((o,r)=>{const i=n.put({key:b(c,a),id:a,org_scope:c,hidden_at_ms:Date.now()});i.onsuccess=()=>o(),i.onerror=()=>r(i.error)}),await e}catch(o){throw await e.catch(()=>{}),o}}async function D(c,a){const t=await _(),s=t.transaction([m],"readonly"),n=s.objectStore(m),e=b(c,a),o=await new Promise(r=>{const i=n.getKey(e);i.onsuccess=()=>r(!!i.result),i.onerror=()=>r(!1)});return await g(s,t,!1),o}async function x(c){const a=await _(),t=a.transaction([m],"readonly"),s=t.objectStore(m),n=`${c}|`,e=[],o=g(t,a,!1);return await new Promise(r=>{const i=s.openCursor();i.onsuccess=()=>{const d=i.result;if(!d){r();return}const u=d.value;typeof(u==null?void 0:u.key)=="string"&&u.key.startsWith(n)&&(u!=null&&u.id)&&e.push(u.id),d.continue()},i.onerror=()=>r()}),await o,e}async function $(){const c=await _(),a=c.transaction([m],"readwrite"),t=a.objectStore(m);let s=0;const n=g(a,c,!0);try{await new Promise((e,o)=>{const r=t.openCursor();r.onsuccess=()=>{const i=r.result;if(!i){e();return}const d=i.delete();d.onsuccess=()=>{s+=1,i.continue()},d.onerror=()=>o(d.error)},r.onerror=()=>o(r.error)}),await n}catch(e){throw await n.catch(()=>{}),e}return s}const k="DWResultsDB",B=1,w="results",y="org_scope",C=14*24*60*60*1e3,p=()=>new Promise((c,a)=>{const t=indexedDB.open(k,B);t.onupgradeneeded=s=>{const n=s.target.result;if(!n.objectStoreNames.contains(w))n.createObjectStore(w,{keyPath:"id"}).createIndex(y,y,{unique:!1});else{const e=s.target.transaction.objectStore(w);e.indexNames.contains(y)||e.createIndex(y,y,{unique:!1})}},t.onsuccess=s=>c(s.target.result),t.onerror=()=>a(t.error)});async function v(c,a,t,s){const n=`${c}|${a}|${t}`,e=`${c}|${a}`,o=await p(),r=o.transaction([w],"readwrite"),i=r.objectStore(w);await new Promise((d,u)=>{const l=i.put({id:n,org_scope:e,payload:s,stored_at_ms:Date.now()});l.onsuccess=()=>d(),l.onerror=()=>u(l.error),r.oncomplete=()=>o.close(),r.onerror=()=>u(r.error)});try{await h()}catch{}try{await N(e,n)}catch{}}async function I(c){const a=await p(),t=a.transaction([w],"readonly"),s=t.objectStore(w).index(y),n=await new Promise((e,o)=>{const r=s.getAll(c);r.onsuccess=()=>e(r.result),r.onerror=()=>o(r.error)});return await new Promise(e=>{t.oncomplete=()=>{a.close(),e()}}),n.length?n.reduce((e,o)=>o.stored_at_ms>e.stored_at_ms?o:e,n[0]):null}async function h(){const c=Date.now()-C,a=await p(),t=a.transaction([w],"readwrite"),s=t.objectStore(w),n={};await new Promise((o,r)=>{const i=s.openCursor();i.onsuccess=()=>{const d=i.result;if(!d){o();return}const u=d.value;n[u.org_scope]||(n[u.org_scope]=[]),n[u.org_scope].push(u),d.continue()},i.onerror=()=>r(i.error)});let e=0;for(const o of Object.keys(n)){const r=n[o];if(!r.length)continue;const i=r.reduce((d,u)=>d.stored_at_ms>u.stored_at_ms?d:u);for(const d of r)typeof d.stored_at_ms=="number"&&d.stored_at_ms<c&&d.id!==i.id&&await new Promise((u,l)=>{const f=s.delete(d.id);f.onsuccess=()=>{e+=1,u()},f.onerror=()=>l(f.error)})}return await new Promise(o=>{t.oncomplete=()=>{a.close(),o()}}),{deleted:e}}async function N(c,a){const t=await p(),s=t.transaction([w],"readwrite"),n=s.objectStore(w),e=n.index(y);let o=0;return await new Promise((r,i)=>{const d=IDBKeyRange.only(c),u=e.openCursor(d);u.onsuccess=()=>{const l=u.result;if(!l){r();return}const f=l.value;if(f.id!==a){const P=n.delete(f.id);P.onsuccess=()=>{o+=1,l.continue()},P.onerror=()=>i(P.error)}else l.continue()},u.onerror=()=>i(u.error)}),await new Promise(r=>{s.oncomplete=()=>{t.close(),r()}}),o}async function O(c){const a=await p(),t=a.transaction([w],"readwrite"),s=t.objectStore(w),n=s.index(y);let e=0;return await new Promise((o,r)=>{const i=IDBKeyRange.only(c),d=n.openCursor(i);d.onsuccess=()=>{const u=d.result;if(!u){o();return}const l=s.delete(u.value.id);l.onsuccess=()=>{e+=1,u.continue()},l.onerror=()=>r(l.error)},d.onerror=()=>r(d.error)}),await new Promise(o=>{t.oncomplete=()=>{a.close(),o()}}),e}async function q(){const c=await p(),a=c.transaction([w],"readwrite"),t=a.objectStore(w);let s=0;return await new Promise((n,e)=>{const o=t.openCursor();o.onsuccess=()=>{const r=o.result;if(!r){n();return}const i=r.delete();i.onsuccess=()=>{s+=1,r.continue()},i.onerror=()=>e(i.error)},o.onerror=()=>e(o.error)}),await new Promise(n=>{a.oncomplete=()=>{c.close(),n()}}),s}export{h as a,$ as b,q as c,O as d,I as g,S as h,D as i,x as l,p as o,v as p};
