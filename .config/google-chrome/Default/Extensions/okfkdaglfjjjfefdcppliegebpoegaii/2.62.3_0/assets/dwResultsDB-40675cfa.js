const j="DWHiddenDB",m="hidden",_=()=>new Promise((c,a)=>{const t=indexedDB.open(j,1);t.onupgradeneeded=s=>{const e=s.target.result;e.objectStoreNames.contains(m)||e.createObjectStore(m,{keyPath:"key"})},t.onsuccess=s=>c(s.target.result),t.onerror=()=>a(t.error)});function g(c,a,t=!0){return new Promise((s,e)=>{const o=n=>{try{a.close()}finally{n&&t?e(n):s()}};c.oncomplete=()=>o(),c.onabort=()=>o(c.error||new Error("Transaction aborted")),c.onerror=()=>o(c.error||new Error("Transaction error"))})}const P=(c,a)=>`${c}|${a}`;async function S(c,a){const t=await _(),s=t.transaction([m],"readwrite"),e=s.objectStore(m),o=g(s,t,!0);try{await new Promise((n,r)=>{const i=e.put({key:P(c,a),id:a,org_scope:c,hidden_at_ms:Date.now()});i.onsuccess=()=>n(),i.onerror=()=>r(i.error)}),await o}catch(n){throw await o.catch(()=>{}),n}}async function D(c,a){const t=await _(),s=t.transaction([m],"readonly"),e=s.objectStore(m),o=P(c,a),n=await new Promise(r=>{const i=e.getKey(o);i.onsuccess=()=>r(!!i.result),i.onerror=()=>r(!1)});return await g(s,t,!1),n}async function x(c){const a=await _(),t=a.transaction([m],"readonly"),s=t.objectStore(m),e=`${c}|`,o=[],n=g(t,a,!1);return await new Promise(r=>{const i=s.openCursor();i.onsuccess=()=>{const d=i.result;if(!d){r();return}const u=d.value;typeof(u==null?void 0:u.key)=="string"&&u.key.startsWith(e)&&(u!=null&&u.id)&&o.push(u.id),d.continue()},i.onerror=()=>r()}),await n,o}async function $(){const c=await _(),a=c.transaction([m],"readwrite"),t=a.objectStore(m);let s=0;const e=g(a,c,!0);try{await new Promise((o,n)=>{const r=t.openCursor();r.onsuccess=()=>{const i=r.result;if(!i){o();return}const d=i.delete();d.onsuccess=()=>{s+=1,i.continue()},d.onerror=()=>n(d.error)},r.onerror=()=>n(r.error)}),await e}catch(o){throw await e.catch(()=>{}),o}return s}const k="DWResultsDB",B=1,w="results",y="org_scope",C=14*24*60*60*1e3,f=()=>new Promise((c,a)=>{const t=indexedDB.open(k,B);t.onupgradeneeded=s=>{const e=s.target.result;if(!e.objectStoreNames.contains(w))e.createObjectStore(w,{keyPath:"id"}).createIndex(y,y,{unique:!1});else{const o=s.target.transaction.objectStore(w);o.indexNames.contains(y)||o.createIndex(y,y,{unique:!1})}},t.onsuccess=s=>c(s.target.result),t.onerror=()=>a(t.error)});async function N(c,a,t,s){const e=`${c}|${a}|${t}`,o=`${c}|${a}`,n=await f(),r=n.transaction([w],"readwrite"),i=r.objectStore(w);await new Promise((d,u)=>{const l=i.put({id:e,org_scope:o,payload:s,stored_at_ms:Date.now()});l.onsuccess=()=>d(),l.onerror=()=>u(l.error),r.oncomplete=()=>n.close(),r.onerror=()=>u(r.error)});try{await h()}catch{}try{await q(o,e)}catch{}}async function O(c){const a=await f(),t=a.transaction([w],"readonly"),s=t.objectStore(w).index(y),e=await new Promise((o,n)=>{const r=s.getAll(c);r.onsuccess=()=>o(r.result),r.onerror=()=>n(r.error)});return await new Promise(o=>{t.oncomplete=()=>{a.close(),o()}}),e.length?e.reduce((o,n)=>n.stored_at_ms>o.stored_at_ms?n:o,e[0]):null}async function h(){const c=Date.now()-C,a=await f(),t=a.transaction([w],"readwrite"),s=t.objectStore(w),e={};await new Promise((n,r)=>{const i=s.openCursor();i.onsuccess=()=>{const d=i.result;if(!d){n();return}const u=d.value;e[u.org_scope]||(e[u.org_scope]=[]),e[u.org_scope].push(u),d.continue()},i.onerror=()=>r(i.error)});let o=0;for(const n of Object.keys(e)){const r=e[n];if(!r.length)continue;const i=r.reduce((d,u)=>d.stored_at_ms>u.stored_at_ms?d:u);for(const d of r)typeof d.stored_at_ms=="number"&&d.stored_at_ms<c&&d.id!==i.id&&await new Promise((u,l)=>{const p=s.delete(d.id);p.onsuccess=()=>{o+=1,u()},p.onerror=()=>l(p.error)})}return await new Promise(n=>{t.oncomplete=()=>{a.close(),n()}}),{deleted:o}}async function q(c,a){const t=await f(),s=t.transaction([w],"readwrite"),e=s.objectStore(w),o=e.index(y);let n=0;return await new Promise((r,i)=>{const d=IDBKeyRange.only(c),u=o.openCursor(d);u.onsuccess=()=>{const l=u.result;if(!l){r();return}const p=l.value;if(p.id!==a){const b=e.delete(p.id);b.onsuccess=()=>{n+=1,l.continue()},b.onerror=()=>i(b.error)}else l.continue()},u.onerror=()=>i(u.error)}),await new Promise(r=>{s.oncomplete=()=>{t.close(),r()}}),n}async function v(){const c=await f(),a=c.transaction([w],"readwrite"),t=a.objectStore(w);let s=0;return await new Promise((e,o)=>{const n=t.openCursor();n.onsuccess=()=>{const r=n.result;if(!r){e();return}const i=r.delete();i.onsuccess=()=>{s+=1,r.continue()},i.onerror=()=>o(i.error)},n.onerror=()=>o(n.error)}),await new Promise(e=>{a.oncomplete=()=>{c.close(),e()}}),s}export{h as a,$ as b,v as c,O as g,S as h,D as i,x as l,f as o,N as p};
