import{g as G,B as q}from"./main-kvjJkSOS.js";var j={exports:{}},V;function se(){if(V)return j.exports;V=1;const e=s=>typeof crypto<"u"&&typeof crypto.getRandomValues=="function"?()=>{const c=crypto.getRandomValues(new Uint8Array(1))[0];return(c>=s?c%s:c).toString(s)}:()=>Math.floor(Math.random()*s).toString(s),r=(s=7,c=!1)=>Array.from({length:s},e(c?16:36)).join("");return j.exports=r,j.exports.default=r,j.exports}var ne=se();const D=G(ne);var te=()=>`uid::${D(7)}`,ae=(e,r=["endpointName","fingerprint"])=>typeof e=="object"&&e!==null&&r.every(s=>s in e),oe=e=>{if(!ae(e))throw new TypeError("Invalid connection args");return JSON.stringify(e)},ie=()=>{let e=[];return{add:(...r)=>{e=[...e,...r]},remove:r=>{e=typeof r=="string"?e.filter(s=>s.message.transactionId!==r):e.filter(s=>!r.includes(s))},entries:()=>e}},L=class{static toBackground(e,r){return e.postMessage(r)}static toExtensionContext(e,r){return e.postMessage(r)}},R={exports:{}},ge=R.exports,z;function me(){return z||(z=1,function(e,r){(function(s,c){c(e)})(typeof globalThis<"u"?globalThis:typeof self<"u"?self:ge,function(s){if(typeof globalThis!="object"||typeof chrome!="object"||!chrome||!chrome.runtime||!chrome.runtime.id)throw new Error("This script should only be loaded in a browser extension.");if(typeof globalThis.browser>"u"||Object.getPrototypeOf(globalThis.browser)!==Object.prototype){const c="The message port closed before a response was received.",u="Returning a Promise is the preferred way to send a reply from an onMessage/onMessageExternal listener, as the sendResponse will be removed from the specs (See https://developer.mozilla.org/docs/Mozilla/Add-ons/WebExtensions/API/runtime/onMessage)",h=o=>{const a={alarms:{clear:{minArgs:0,maxArgs:1},clearAll:{minArgs:0,maxArgs:0},get:{minArgs:0,maxArgs:1},getAll:{minArgs:0,maxArgs:0}},bookmarks:{create:{minArgs:1,maxArgs:1},get:{minArgs:1,maxArgs:1},getChildren:{minArgs:1,maxArgs:1},getRecent:{minArgs:1,maxArgs:1},getSubTree:{minArgs:1,maxArgs:1},getTree:{minArgs:0,maxArgs:0},move:{minArgs:2,maxArgs:2},remove:{minArgs:1,maxArgs:1},removeTree:{minArgs:1,maxArgs:1},search:{minArgs:1,maxArgs:1},update:{minArgs:2,maxArgs:2}},browserAction:{disable:{minArgs:0,maxArgs:1,fallbackToNoCallback:!0},enable:{minArgs:0,maxArgs:1,fallbackToNoCallback:!0},getBadgeBackgroundColor:{minArgs:1,maxArgs:1},getBadgeText:{minArgs:1,maxArgs:1},getPopup:{minArgs:1,maxArgs:1},getTitle:{minArgs:1,maxArgs:1},openPopup:{minArgs:0,maxArgs:0},setBadgeBackgroundColor:{minArgs:1,maxArgs:1,fallbackToNoCallback:!0},setBadgeText:{minArgs:1,maxArgs:1,fallbackToNoCallback:!0},setIcon:{minArgs:1,maxArgs:1},setPopup:{minArgs:1,maxArgs:1,fallbackToNoCallback:!0},setTitle:{minArgs:1,maxArgs:1,fallbackToNoCallback:!0}},browsingData:{remove:{minArgs:2,maxArgs:2},removeCache:{minArgs:1,maxArgs:1},removeCookies:{minArgs:1,maxArgs:1},removeDownloads:{minArgs:1,maxArgs:1},removeFormData:{minArgs:1,maxArgs:1},removeHistory:{minArgs:1,maxArgs:1},removeLocalStorage:{minArgs:1,maxArgs:1},removePasswords:{minArgs:1,maxArgs:1},removePluginData:{minArgs:1,maxArgs:1},settings:{minArgs:0,maxArgs:0}},commands:{getAll:{minArgs:0,maxArgs:0}},contextMenus:{remove:{minArgs:1,maxArgs:1},removeAll:{minArgs:0,maxArgs:0},update:{minArgs:2,maxArgs:2}},cookies:{get:{minArgs:1,maxArgs:1},getAll:{minArgs:1,maxArgs:1},getAllCookieStores:{minArgs:0,maxArgs:0},remove:{minArgs:1,maxArgs:1},set:{minArgs:1,maxArgs:1}},devtools:{inspectedWindow:{eval:{minArgs:1,maxArgs:2,singleCallbackArg:!1}},panels:{create:{minArgs:3,maxArgs:3,singleCallbackArg:!0},elements:{createSidebarPane:{minArgs:1,maxArgs:1}}}},downloads:{cancel:{minArgs:1,maxArgs:1},download:{minArgs:1,maxArgs:1},erase:{minArgs:1,maxArgs:1},getFileIcon:{minArgs:1,maxArgs:2},open:{minArgs:1,maxArgs:1,fallbackToNoCallback:!0},pause:{minArgs:1,maxArgs:1},removeFile:{minArgs:1,maxArgs:1},resume:{minArgs:1,maxArgs:1},search:{minArgs:1,maxArgs:1},show:{minArgs:1,maxArgs:1,fallbackToNoCallback:!0}},extension:{isAllowedFileSchemeAccess:{minArgs:0,maxArgs:0},isAllowedIncognitoAccess:{minArgs:0,maxArgs:0}},history:{addUrl:{minArgs:1,maxArgs:1},deleteAll:{minArgs:0,maxArgs:0},deleteRange:{minArgs:1,maxArgs:1},deleteUrl:{minArgs:1,maxArgs:1},getVisits:{minArgs:1,maxArgs:1},search:{minArgs:1,maxArgs:1}},i18n:{detectLanguage:{minArgs:1,maxArgs:1},getAcceptLanguages:{minArgs:0,maxArgs:0}},identity:{launchWebAuthFlow:{minArgs:1,maxArgs:1}},idle:{queryState:{minArgs:1,maxArgs:1}},management:{get:{minArgs:1,maxArgs:1},getAll:{minArgs:0,maxArgs:0},getSelf:{minArgs:0,maxArgs:0},setEnabled:{minArgs:2,maxArgs:2},uninstallSelf:{minArgs:0,maxArgs:1}},notifications:{clear:{minArgs:1,maxArgs:1},create:{minArgs:1,maxArgs:2},getAll:{minArgs:0,maxArgs:0},getPermissionLevel:{minArgs:0,maxArgs:0},update:{minArgs:2,maxArgs:2}},pageAction:{getPopup:{minArgs:1,maxArgs:1},getTitle:{minArgs:1,maxArgs:1},hide:{minArgs:1,maxArgs:1,fallbackToNoCallback:!0},setIcon:{minArgs:1,maxArgs:1},setPopup:{minArgs:1,maxArgs:1,fallbackToNoCallback:!0},setTitle:{minArgs:1,maxArgs:1,fallbackToNoCallback:!0},show:{minArgs:1,maxArgs:1,fallbackToNoCallback:!0}},permissions:{contains:{minArgs:1,maxArgs:1},getAll:{minArgs:0,maxArgs:0},remove:{minArgs:1,maxArgs:1},request:{minArgs:1,maxArgs:1}},runtime:{getBackgroundPage:{minArgs:0,maxArgs:0},getPlatformInfo:{minArgs:0,maxArgs:0},openOptionsPage:{minArgs:0,maxArgs:0},requestUpdateCheck:{minArgs:0,maxArgs:0},sendMessage:{minArgs:1,maxArgs:3},sendNativeMessage:{minArgs:2,maxArgs:2},setUninstallURL:{minArgs:1,maxArgs:1}},sessions:{getDevices:{minArgs:0,maxArgs:1},getRecentlyClosed:{minArgs:0,maxArgs:1},restore:{minArgs:0,maxArgs:1}},storage:{local:{clear:{minArgs:0,maxArgs:0},get:{minArgs:0,maxArgs:1},getBytesInUse:{minArgs:0,maxArgs:1},remove:{minArgs:1,maxArgs:1},set:{minArgs:1,maxArgs:1}},managed:{get:{minArgs:0,maxArgs:1},getBytesInUse:{minArgs:0,maxArgs:1}},sync:{clear:{minArgs:0,maxArgs:0},get:{minArgs:0,maxArgs:1},getBytesInUse:{minArgs:0,maxArgs:1},remove:{minArgs:1,maxArgs:1},set:{minArgs:1,maxArgs:1}}},tabs:{captureVisibleTab:{minArgs:0,maxArgs:2},create:{minArgs:1,maxArgs:1},detectLanguage:{minArgs:0,maxArgs:1},discard:{minArgs:0,maxArgs:1},duplicate:{minArgs:1,maxArgs:1},executeScript:{minArgs:1,maxArgs:2},get:{minArgs:1,maxArgs:1},getCurrent:{minArgs:0,maxArgs:0},getZoom:{minArgs:0,maxArgs:1},getZoomSettings:{minArgs:0,maxArgs:1},goBack:{minArgs:0,maxArgs:1},goForward:{minArgs:0,maxArgs:1},highlight:{minArgs:1,maxArgs:1},insertCSS:{minArgs:1,maxArgs:2},move:{minArgs:2,maxArgs:2},query:{minArgs:1,maxArgs:1},reload:{minArgs:0,maxArgs:2},remove:{minArgs:1,maxArgs:1},removeCSS:{minArgs:1,maxArgs:2},sendMessage:{minArgs:2,maxArgs:3},setZoom:{minArgs:1,maxArgs:2},setZoomSettings:{minArgs:1,maxArgs:2},update:{minArgs:1,maxArgs:2}},topSites:{get:{minArgs:0,maxArgs:0}},webNavigation:{getAllFrames:{minArgs:1,maxArgs:1},getFrame:{minArgs:1,maxArgs:1}},webRequest:{handlerBehaviorChanged:{minArgs:0,maxArgs:0}},windows:{create:{minArgs:0,maxArgs:1},get:{minArgs:1,maxArgs:2},getAll:{minArgs:0,maxArgs:1},getCurrent:{minArgs:0,maxArgs:1},getLastFocused:{minArgs:0,maxArgs:1},remove:{minArgs:1,maxArgs:1},update:{minArgs:2,maxArgs:2}}};if(Object.keys(a).length===0)throw new Error("api-metadata.json has not been included in browser-polyfill");class l extends WeakMap{constructor(t,m=void 0){super(m),this.createItem=t}get(t){return this.has(t)||this.set(t,this.createItem(t)),super.get(t)}}const i=n=>n&&typeof n=="object"&&typeof n.then=="function",y=(n,t)=>(...m)=>{o.runtime.lastError?n.reject(new Error(o.runtime.lastError.message)):t.singleCallbackArg||m.length<=1&&t.singleCallbackArg!==!1?n.resolve(m[0]):n.resolve(m)},d=n=>n==1?"argument":"arguments",w=(n,t)=>function(A,...b){if(b.length<t.minArgs)throw new Error(`Expected at least ${t.minArgs} ${d(t.minArgs)} for ${n}(), got ${b.length}`);if(b.length>t.maxArgs)throw new Error(`Expected at most ${t.maxArgs} ${d(t.maxArgs)} for ${n}(), got ${b.length}`);return new Promise((_,E)=>{if(t.fallbackToNoCallback)try{A[n](...b,y({resolve:_,reject:E},t))}catch(g){console.warn(`${n} API method doesn't seem to support the callback parameter, falling back to call it without a callback: `,g),A[n](...b),t.fallbackToNoCallback=!1,t.noCallback=!0,_()}else t.noCallback?(A[n](...b),_()):A[n](...b,y({resolve:_,reject:E},t))})},p=(n,t,m)=>new Proxy(t,{apply(A,b,_){return m.call(b,n,..._)}});let f=Function.call.bind(Object.prototype.hasOwnProperty);const S=(n,t={},m={})=>{let A=Object.create(null),b={has(E,g){return g in n||g in A},get(E,g,k){if(g in A)return A[g];if(!(g in n))return;let x=n[g];if(typeof x=="function")if(typeof t[g]=="function")x=p(n,n[g],t[g]);else if(f(m,g)){let P=w(g,m[g]);x=p(n,n[g],P)}else x=x.bind(n);else if(typeof x=="object"&&x!==null&&(f(t,g)||f(m,g)))x=S(x,t[g],m[g]);else if(f(m,"*"))x=S(x,t[g],m["*"]);else return Object.defineProperty(A,g,{configurable:!0,enumerable:!0,get(){return n[g]},set(P){n[g]=P}}),x;return A[g]=x,x},set(E,g,k,x){return g in A?A[g]=k:n[g]=k,!0},defineProperty(E,g,k){return Reflect.defineProperty(A,g,k)},deleteProperty(E,g){return Reflect.deleteProperty(A,g)}},_=Object.create(n);return new Proxy(_,b)},v=n=>({addListener(t,m,...A){t.addListener(n.get(m),...A)},hasListener(t,m){return t.hasListener(n.get(m))},removeListener(t,m){t.removeListener(n.get(m))}}),N=new l(n=>typeof n!="function"?n:function(m){const A=S(m,{},{getContent:{minArgs:0,maxArgs:0}});n(A)});let M=!1;const I=new l(n=>typeof n!="function"?n:function(m,A,b){let _=!1,E,g=new Promise(O=>{E=function(T){M||(console.warn(u,new Error().stack),M=!0),_=!0,O(T)}}),k;try{k=n(m,A,E)}catch(O){k=Promise.reject(O)}const x=k!==!0&&i(k);if(k!==!0&&!x&&!_)return!1;const P=O=>{O.then(T=>{b(T)},T=>{let F;T&&(T instanceof Error||typeof T.message=="string")?F=T.message:F="An unexpected error occurred",b({__mozWebExtensionPolyfillReject__:!0,message:F})}).catch(T=>{console.error("Failed to send onMessage rejected reply",T)})};return P(x?k:g),!0}),ee=({reject:n,resolve:t},m)=>{o.runtime.lastError?o.runtime.lastError.message===c?t():n(new Error(o.runtime.lastError.message)):m&&m.__mozWebExtensionPolyfillReject__?n(new Error(m.message)):t(m)},U=(n,t,m,...A)=>{if(A.length<t.minArgs)throw new Error(`Expected at least ${t.minArgs} ${d(t.minArgs)} for ${n}(), got ${A.length}`);if(A.length>t.maxArgs)throw new Error(`Expected at most ${t.maxArgs} ${d(t.maxArgs)} for ${n}(), got ${A.length}`);return new Promise((b,_)=>{const E=ee.bind(null,{resolve:b,reject:_});A.push(E),m.sendMessage(...A)})},re={devtools:{network:{onRequestFinished:v(N)}},runtime:{onMessage:v(I),onMessageExternal:v(I),sendMessage:U.bind(null,"sendMessage",{minArgs:1,maxArgs:3})},tabs:{sendMessage:U.bind(null,"sendMessage",{minArgs:2,maxArgs:3})}},B={clear:{minArgs:1,maxArgs:1},get:{minArgs:1,maxArgs:1},set:{minArgs:1,maxArgs:1}};return a.privacy={network:{"*":B},services:{"*":B},websites:{"*":B}},S(o,re,a)};s.exports=h(chrome)}else s.exports=globalThis.browser})}(R)),R.exports}var le=me();const ce=G(le);var ve=(e="")=>{const r=te();let s,c=[];const u=ie(),h=new Set,o=new Set,a=(i,y)=>{switch(i.status){case"undeliverable":c.some(d=>d.message.messageID===i.message.messageID)||(c=[...c,{message:i.message,resolvedDestination:i.resolvedDestination}]);return;case"deliverable":c=c.reduce((d,w)=>w.resolvedDestination===i.deliverableTo?(L.toBackground(y,{type:"deliver",message:w.message}),d):[...d,w],[]);return;case"delivered":i.receipt.message.messageType==="message"&&u.add(i.receipt);return;case"incoming":i.message.messageType==="reply"&&u.remove(i.message.messageID),h.forEach(d=>d(i.message,y));return;case"terminated":{const d=u.entries().filter(w=>i.fingerprint===w.to);u.remove(d),d.forEach(({message:w})=>o.forEach(p=>p(w)))}}},l=()=>{s=ce.runtime.connect({name:oe({endpointName:e,fingerprint:r})}),s.onMessage.addListener(a),s.onDisconnect.addListener(l),L.toBackground(s,{type:"sync",pendingResponses:u.entries(),pendingDeliveries:[...new Set(c.map(({resolvedDestination:i})=>i))]})};return l(),{onFailure(i){o.add(i)},onMessage(i){h.add(i)},postMessage(i){L.toBackground(s,{type:"deliver",message:i})}}},Ae=Object.defineProperty,de=Object.defineProperties,ue=Object.getOwnPropertyDescriptors,J=Object.getOwnPropertySymbols,fe=Object.prototype.hasOwnProperty,pe=Object.prototype.propertyIsEnumerable,Z=(e,r,s)=>r in e?Ae(e,r,{enumerable:!0,configurable:!0,writable:!0,value:s}):e[r]=s,H=(e,r)=>{for(var s in r||(r={}))fe.call(r,s)&&Z(e,s,r[s]);if(J)for(var s of J(r))pe.call(r,s)&&Z(e,s,r[s]);return e},K=(e,r)=>de(e,ue(r)),xe=/^((?:background$)|devtools|popup|options|content-script|window)(?:@(\d+)(?:\.(\d+))?)?$/,Q=e=>{const[,r,s,c]=e.match(xe)||[];return{context:r,tabId:+s,frameId:c?+c:void 0}};const he=[{property:"name",enumerable:!1},{property:"message",enumerable:!1},{property:"stack",enumerable:!1},{property:"code",enumerable:!0}],W=Symbol(".toJSON was called"),be=e=>{e[W]=!0;const r=e.toJSON();return delete e[W],r},Y=({from:e,seen:r,to_:s,forceEnumerable:c,maxDepth:u,depth:h})=>{const o=s||(Array.isArray(e)?[]:{});if(r.push(e),h>=u)return o;if(typeof e.toJSON=="function"&&e[W]!==!0)return be(e);for(const[a,l]of Object.entries(e)){if(typeof q=="function"&&q.isBuffer(l)){o[a]="[object Buffer]";continue}if(l!==null&&typeof l=="object"&&typeof l.pipe=="function"){o[a]="[object Stream]";continue}if(typeof l!="function"){if(!l||typeof l!="object"){o[a]=l;continue}if(!r.includes(e[a])){h++,o[a]=Y({from:e[a],seen:[...r],forceEnumerable:c,maxDepth:u,depth:h});continue}o[a]="[Circular]"}}for(const{property:a,enumerable:l}of he)typeof e[a]=="string"&&Object.defineProperty(o,a,{value:e[a],enumerable:!0,configurable:!0,writable:!0});return o};function ye(e,r={}){const{maxDepth:s=Number.POSITIVE_INFINITY}=r;return typeof e=="object"&&e!==null?Y({from:e,seen:[],forceEnumerable:!0,maxDepth:s,depth:0}):typeof e=="function"?`[Function: ${e.name||"anonymous"}]`:e}let X=()=>({events:{},emit(e,...r){(this.events[e]||[]).forEach(s=>s(...r))},on(e,r){return(this.events[e]=this.events[e]||[]).push(r),()=>this.events[e]=(this.events[e]||[]).filter(s=>s!==r)}});var _e=(e,r,s)=>{const c=D(),u=new Map,h=new Map,o=a=>{if(a.destination.context===e&&!a.destination.frameId&&!a.destination.tabId){const{transactionId:l,messageID:i,messageType:y}=a,d=()=>{const p=u.get(l);if(p){const{err:f,data:S}=a;if(f){const v=f,N=self[v.name],M=new(typeof N=="function"?N:Error)(v.message);for(const I in v)M[I]=v[I];p.reject(M)}else p.resolve(S);u.delete(l)}},w=async()=>{let p,f,S=!1;try{const v=h.get(i);if(typeof v=="function")p=await v({sender:a.origin,id:i,data:a.data,timestamp:a.timestamp});else throw S=!0,new Error(`[webext-bridge] No handler registered in '${e}' to accept messages with id '${i}'`)}catch(v){f=v}finally{if(f&&(a.err=ye(f)),o(K(H({},a),{messageType:"reply",data:p,origin:{context:e,tabId:null},destination:a.origin,hops:[]})),f&&!S)throw p}};switch(y){case"reply":return d();case"message":return w()}}return a.hops.push(`${e}::${c}`),r(a)};return{handleMessage:o,endTransaction:a=>{const l=u.get(a);l?.reject("Transaction was ended before it could complete"),u.delete(a)},sendMessage:(a,l,i="background")=>{const y=typeof i=="string"?Q(i):i,d="Bridge#sendMessage ->";if(!y.context)throw new TypeError(`${d} Destination must be any one of known destinations`);return new Promise((w,p)=>{const f={messageID:a,data:l,destination:y,messageType:"message",transactionId:D(),origin:{context:e,tabId:null},hops:[],timestamp:Date.now()};u.set(f.transactionId,{resolve:w,reject:p});try{o(f)}catch(S){u.delete(f.transactionId),p(S)}})},onMessage:(a,l)=>(h.set(a,l),()=>h.delete(a))}},C=class{constructor(e,r){this.endpointRuntime=e,this.streamInfo=r,this.emitter=X(),this.isClosed=!1,this.handleStreamClose=()=>{this.isClosed||(this.isClosed=!0,this.emitter.emit("closed",!0),this.emitter.events={})},C.initDone||(e.onMessage("__crx_bridge_stream_transfer__",s=>{const{streamId:c,streamTransfer:u,action:h}=s.data,o=C.openStreams.get(c);o&&!o.isClosed&&(h==="transfer"&&o.emitter.emit("message",u),h==="close"&&(C.openStreams.delete(c),o.handleStreamClose()))}),C.initDone=!0),C.openStreams.set(this.streamInfo.streamId,this)}get info(){return this.streamInfo}send(e){if(this.isClosed)throw new Error("Attempting to send a message over closed stream. Use stream.onClose(<callback>) to keep an eye on stream status");this.endpointRuntime.sendMessage("__crx_bridge_stream_transfer__",{streamId:this.streamInfo.streamId,streamTransfer:e,action:"transfer"},this.streamInfo.endpoint)}close(e){e&&this.send(e),this.handleStreamClose(),this.endpointRuntime.sendMessage("__crx_bridge_stream_transfer__",{streamId:this.streamInfo.streamId,streamTransfer:null,action:"close"},this.streamInfo.endpoint)}onMessage(e){return this.getDisposable("message",e)}onClose(e){return this.getDisposable("closed",e)}getDisposable(e,r){const s=this.emitter.on(e,r);return Object.assign(s,{dispose:s,close:s})}},$=C;$.initDone=!1;$.openStreams=new Map;var Ee=e=>{const r=new Map,s=new Map,c=X();e.onMessage("__crx_bridge_stream_open__",o=>new Promise(a=>{const{sender:l,data:i}=o,{channel:y}=i;let d=!1,w=()=>{};const p=()=>{const f=s.get(y);typeof f=="function"?(f(new $(e,K(H({},i),{endpoint:l}))),d&&w(),a(!0)):d||(d=!0,w=c.on("did-change-stream-callbacks",p))};p()}));async function u(o,a){if(r.has(o))throw new Error("webext-bridge: A Stream is already open at this channel");const l=typeof a=="string"?Q(a):a,i={streamId:D(),channel:o,endpoint:l},y=new $(e,i);return y.onClose(()=>r.delete(o)),await e.sendMessage("__crx_bridge_stream_open__",i,l),r.set(o,y),y}function h(o,a){if(s.has(o))throw new Error("webext-bridge: This channel has already been claimed. Stream allows only one-on-one communication");s.set(o,a),c.emit("did-change-stream-callbacks")}return{openStream:u,onOpenStreamChannel:h}};export{ve as a,Ee as b,_e as c};
